# 데이터베이스

## #1. 데이터베이스

특정 조직의 여러 사용자가 **공유**하여 사용할 수 있도록 **통합**해서 **저장**한 **운영 데이터**의 집합

### 특징

* 실시간 접근
* 계속 변화: 데이터의 계속적인 I, D, U를 통해 정확한 데이터 유지
* 동시 공유
* 내용 기반 참조: 주소나 위치가 아닌 내용으로 참조

### 데이터 모델

데이터 모델링이란 현실 세계에 존재하는 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 과정을 의미합니다. 

#### 개념적 데이터 모델링

사람의 머리로 이해할 수 있도록 현실 세계를 개념적으로 모델링합니다.

> ERD(Entity Relationship Diagram)
>
> ER 모델의 구성 요소는 1) 개체 2) 관계 3) 속성

#### 논리적 데이터 모델링

개념적 구조를 논리적으로 모델링하여 데이터베이스의 논리적 구조로 표현합니다.

#### 물리적 데이터 모델링

### 확장

1. 수직적 확장: CPU업그레이드와 같이 단순히 서버의 성능을 향상시키는 것입니다.
2. 수평적 확장: 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미합니다. (NoSQL에서만 가능) (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)

## #2. SQL

데이터 정의어 (DDL): **테이블** 생성, 변경, 제거하는 기능을 제공합니다. (CREATE, ALTER, DROP)

데이터 조작어 (DML): 테이블에서 새 **데이터**를 삽입하거나, 테이블에 저장된 데이터를 수정, 삭제, 검색하는 기능을 제공합니다. (SELECT, INSERT, DELETE, UPDATE)

데이터 제어어 (DCL): 보안을 위해 데이터에 대한 접근 및 사용 권한을 제어하는 기능을 제공합니다.

* 뷰

## #3. Key

키란 검색과 정렬 시 튜플을 구분할 수 있는 기준이 되는 속성을 얘기합니다.

### 후보키

후보키는 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합입니다. 이 때, 유일성과 최소성을 만족해야 합니다. 유일성이란, 키로 하나의 튜플을 유일하게 식별할 수 있는 것을 의미하고 최소성이란 꼭 필요한 속성으로만 구성하는 것을 의미합니다.

### 기본키

기본키란 후보키 중 선택한 메인 키 입니다. Null값을 가질 수 없고, 동일한 값이 중복될 수 없습니다.

### 대체키

대체키란 후보키 중 기본키를 제외한 나머지키를 의미합니다.

### 슈퍼키

슈퍼키란 유일성은 만족하지만 최소성은 만족하지 못하는 키를 의미합니다.

### 외래키

외래키는 두 테이블을 서로 연결하는 데 사용되는 키를 의미합니다.

## #4. Join

조인이란 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법을 의미합니다.

### Inner join

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F99799F3E5A8148D7036659" width=100>



교집합으로 기준 테이블과 join 테이블의 중복된 값을 보여줍니다.

### Left outer join

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F997E7F415A81490507F027" width=100>

기준테이블값과 조인테이블과 중복된 값을 보여줍니다.

``` mysql
SELECT A.name, b.age
FROM ex_table A
LEFT OUTER JOIN join_table B ON A.no_emp = B.no_emp;
```

### Right outer join

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F9984CE355A8149180ABD1D" width=100>

### Full outer join

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F99195F345A8149391BE0C3" width=100>

합집합을 말하며 A와 B테이블의 모든 데이터가 검색됩니다.

### Cross join

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F993F4E445A8A2D281AC66B" width=100>

모든 경우의 수를 전부 표현해주는 방식입니다.

### Self join

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F99341D335A8A363D0614E8" width=100>

자기자신과 자기자신을 조인하는 것입니다.

## #5. 이상

### 삽입 이상

기본키가 {Student ID, Course ID} 인 경우, 미수강 학생을 추가할 때 course ID를 '미수강'과 같은 의미없는 아이디를 생성해야합니다. 이렇게 **불필요한 데이터를 추가**해야지 삽입할 수 있는 상황을 의미합니다.

### 갱신 이상

전공을 컴퓨터에서 음악으로 바꾸는 경우 모든 전공을 음악으로 바꿔야하지만 일부를 깜빡하고 바꾸지 못하는 경우를 의미합니다. 이렇게 **일부만 변경**해 데이터 불일치가 발생하는 경우를 의미합니다.

### 삭제 이상

학생이 수강을 철회하는 경우 학생의 모든 정보가 삭제되는 경우를 의미합니다. 즉, 튜플 삭제로 인해 **꼭 필요한 데이터까지 함께 삭제**되는 문제를 의미합니다.

## #6. 정규화

이상현상을 제거하면서 릴레이션을 분해하는 과정을 의미합니다. 

### 함수적종속성

함수적 종속성을 이용해 연관성이 있는 속성들로만 구성하도록 분해해 바람직한 릴레이션으로 만들어나가는 과정을 의미합니다.

[정규화과정](https://m.blog.naver.com/PostView.nhn?blogId=james_parku&logNo=110177520184&proxyReferer=https:%2F%2Fwww.google.com%2F) [BCNF](https://yaboong.github.io/database/2018/03/10/database-normalization-2/) [제4정규형](https://zzozzomin08.tistory.com/12)

### 정규화 과정

![image-20201220224904481](C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\image-20201220224904481.png)

#### 제1 정규형

릴레이션의 **모든 속성이** 더는 분해되지 않는 **원자값**을 가지는 경우

#### 제2 정규형

릴레이션이 제1 정규형에 속하고, 기본키가 아닌 모든 속성이 **기본키에 완전 함수 종속**되는 경우

#### 제3 정규형

릴레이션이 제2 정규형에 속하고, 기본키가 아닌 모든 속성이 **기본키에 이행적 함수 종속**되지 않는 경우

> 이행적 함수 종속 관계란? 
>
> 만약 A값을 알 때,B값을 알 수 있고 B값을 알 때 C값을 알 수 있으면 이를 이행적함수종속관계라고 합니다. A-> B, B->C 와 같은 관계

#### 보이스/코드 정규형(BCNF)

제3 정규형까지 모두 만족하고, 하나의 릴레이션에 여러 후보키가 존재하지 않도록 만드는 것

#### 제4 정규형

BCNF형까지 만족하고, **다치 종속성** 문제를 해결하는 경우. 즉, **애트리뷰트가** 값이 원자값이 아닌 **값을 여러개 갖는** 릴레이션을 분해하여 **애트리뷰트가 원자값을 갖도록** 하는 정규형이다.

> 다치종속?
>
> 두개의 독립된 애트리뷰트가 **1:N 관계로 대응**하는 관계로, '**↠**'화살표로 종속성을 표시한다.

#### 제5 정규형

제 4 정규형을 만족하면서, 후보키를 통하지 않는 조인종속을 제거하는 경우. 분할하고(Projection) 합치는(Join) 개념 때문에 PJ(Project-Join Normal Form) 이라고도 한다.

> 조인종속성 (Join Dependency)
>
> 한 릴레이션이 여러 Projection으로 무손실분해될 수 있는 가능성을 조인종속 또는 JD라 부른다

## #7. 역정규화

역정규화란 정규화를 통해 분리되었던 릴레이션에 중복을 허용하고 다시 통합하거나 분할하여 구조를 재조정하는 과정입니다. 

외래키를 이용해 참조해야하는 상황이 많아지면, 데이터베이스에 저장된 자료를 검색하는 시간을 증가시키고 성능을 저하시킬 수 있습니다. 따라서, 물리적 설계 과정에서 성능을 향상시키기 위해 역정규화를 실행합니다.

### 릴레이션 역정규화

두 릴레이션간 잦은 참조로 릴레이션을 **병합**하거나, 자주사용하는 속성이나 튜플을 **분할**해 사용합니다. 수직분할의 경우 <u>자주 사용하는 속성과 그렇지 않은 속성</u>을 분할하는 것이고, 수평 분할은 <u>자주 사용하는 튜플과 그렇지 않는 튜플</u>을 구분해서 분할하는 것입니다. (수직: 속성 / 수평: 튜플)

### 속성 역정규화

릴레이션의 성능을 향상시키기 위해 속성 또는 파생 속성을 추가합니다.

> 파생 속성?
>
> 현재 릴레이션에는 없는 속성이지만 작업의 효율을 위해 속성으로부터의 계산이나 가공에 의해 파생되는 속성입니다.

## #8. 트랜잭션

데이터베이스의 상태를 변화시키기 위해 수행하는 가장 작은 작업 단위입니다.

### 특징

1. 원자성: 트랜잭션이 모두 DB에 반영되거나 혹은 전혀 반영되지 않아야 합니다. (회복 기능)
2. 일관성: 작업 처리 결과는 항상 일관성 있어야합니다. (병행 제어 기능)
3. 독립성: 수행중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없습니다. (병행 제어 기능)
4. 지속성: 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 합니다. (회복 기능)

### Commit & Transaction

* Commit: 하나의 트랜잭션이 성공으로 끝났고, DB가 일관성 있는 상태일 때 **하나의 트랜잭션 과정을 종료하게 된다.** 성공적으로 완료되었음을 선언하는 연산.
* Rollback: 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진경우 **하나의 묶음 처리가 시작되기 이전의 상태로 되돌린다.** 수행이 실패했음을 선언하는 연산.

## SQL vs. NoSQL

### SQL

SQL을 사용하면 데이터가 명확하게 정의된 스키마에 따라 테이블에 저장됩니다. (데이터의 무결성) 또한, 데이터는 관계를 통해 여러 테이블에 분산됩니다.

### NoSQL

NoSQL이란 비관계형 DB로 스키마도 없고, 관계도 없습니다. SQL은 정해진 스키마를 따르지 않으면 데이터가 추가가 불가능했지만, NoSQL의 경우 다른 구조의 데이터를 같은 컬렉션에 추가가 가능합니다. 데이터 중복이 있어 수정 시 모든 컬렉션에서 수정해야 합니다.

### SQL과 NoSQL 선택

관계를 맺고 있는 데이터가 자주 변경되거나 (NoSQL은 모든 컬렉션을 수정해야하기 때문에 비효율적) 명확한 스키마가 사용자와 데이터에게 중요한 경우에 SQL를 사용합니다.

정확한 데이터 구조를 알 수 없거나 변경/확장될 수 있는 경우와 읽기를 자주 하지만 변경은 자주 없는 경우, 수평으로 확장해야하는 경우에 NoSQL을 사용합니다.

### Redis

오픈 소스 기반 인 메모리 키 값 데이터 구조 스토어를 의미합니다. 보통 DB의 경우 하드디스크나 SSD에 저장하지만, Redis는 메모리(RAM)에 저장해 디스크 스캐닝이 필요없어 매우 빠릅니다.

휘발성이 있어 백업 과정이 존재하는데, snapshot(특정 지점을 설정하고 디스크에 백업)과 AOF(Append Only File)(명령(쿼리)들을 저장해두고 서버가 셧다운되면 재실행해서 다시 만들어 놓는 것)이 있습니다.

## Index

RDBMS에서 검색 속도를 높이기 위한 기술로 테이블의 컬럼을 색인화해 따로 파일로 저장합니다. 해당 테이블의 레코드를 full scan하지 않고 색인화된 (B+ Tree 구조) 인덱스 파일 검색으로 검색 속도를 향상시킵니다.

테이블 생성하면 **MYD, MYI, FRM** 3개의 파일이 생성됩니다. 인덱스를 사용하지 않는 경우, MYI파일은 비어있지만 인덱싱 하는 경우 MYI 파일이 생성됩니다. 이후에 SELECT 쿼리로 인덱스를 사용하는 컬럼을 탐색 시 MYI 파일의 내용을 검색합니다.

* FRM: 테이블 구조가 저장
* MYD: 실제 데이터가 있는 파일
* MYI: Index 정보가 들어있는 파일

데이터 추가, 삭제, 변경이 자주 일어나는 경우 인덱스를 재작성 해야하므로 성능에 영향을 미칩니다.

join이나 Where절에서 자주 사용되거나 외래키가 사용되는 컬럼에서 인덱스를 사용하면 좋습니다.

Update시, delete를 한 다음 insert를 해야함 (2배의 작업)

## DBMS

### DBMS의 구조

질의처리기 / 저장시스템

* Undo: 정상적으로 종료되지 않은 트랜잭션이 변경한 페이지들을 원상 복구하는 것을 의미합니다.
* Redo: 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업을 의미합니다.